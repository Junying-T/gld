---
title: "factor_levels_sandbox"
author: "Tom"
date: "June 14, 2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(error = TRUE)

library(tidyverse)
library(retroharmonize)
library(readxl)
library(openxlsx)
library(haven)

# paths ----

  # user 
  
  user <- 5   # 1 
  

  
  # top folders 
  
  if (user == 5) {
    
    data		<- ""					# data folder
    GLD 		<- "Y:"					# set this to the letter the GLD drive is on your computer
    i2d2 	  <- "Z"					# set this to the letter the I2D2 drive is on your computer
    clone	  <- "C:/Users/WB551206/local/GitHub" # github/code top folder

  }
  
  
  if (user == 1) {
    
    data		<- ""					# data folder
    GLD 		<- ""					# set this to the letter the GLD drive is on your computer
    i2d2 	  <- ""					# set this to the letter the I2D2 drive is on your computer
    clone	  <- "C:/Users/..." # github/code top folder
    
  }
  
  
  # Same no matter the user 
    code 	        <- file.path(clone, "gld/GLD")
    yr2012        <- file.path(GLD, "GLD-Harmonization/551206_TM/PHL/PHL_2012_LFS") #  our directory
      yr2012data  <- file.path(yr2012, "PHL_2012_LFS_v01_M/Data/Stata")          # data directory 
        vSPSS     <- file.path(yr2012data, "SPSS")
      yr2012doc   <- file.path(yr2012, "PHL_2012_LFS_v01_M_v01_A_I2D2/Doc")      # documents 
      
    
    
  
```


# Exploration of how to harmonize factor labels across same-year survey rounds


## Method 1: iecodebook 

I have already generated an output xlsx of all the data labels of all rounds from iecodebook. So The strategy here is to simply read in these four tabs (one for each round) directly and use `dplyr` to find distinct/unique vectors. Then write an output `.xlsx` of this object.
```{r}

## import labels -------            
jan2012 <- read_xlsx(
  path = file.path(yr2012doc, "PHL_2012_append_template.xlsx"),
  sheet = "choices_JAN2012",
  col_names = TRUE
)      
   
apr2012 <- read_xlsx(
  path = file.path(yr2012doc, "PHL_2012_append_template.xlsx"),
  sheet = "choices_APR2012",
  col_names = TRUE
)  

jul2012 <- read_xlsx(
  path = file.path(yr2012doc, "PHL_2012_append_template.xlsx"),
  sheet = "choices_JUL2012",
  col_names = TRUE
) 

oct2012 <- read_xlsx(
  path = file.path(yr2012doc, "PHL_2012_append_template.xlsx"),
  sheet = "choices_OCT2012",
  col_names = TRUE
) 

```

After importing we can append and then use `distinct()` to determine uniqueness. But we only want to determine uniqueness by the first two variables, `list_name` and `value`. The final one, `label` is the actual string label and for now I don't really care if that's different if the value is the same. This is up for debate: it is possible that the difference could be trivial (a space) or it could be a significant difference, such as a mislabeled factor. For now, I will only use the first two variables to determine uniqueness.

```{r}

## append ----
# simply, slowly, make a long version, obvs with dups first
long_2012 <- bind_rows(jan2012, apr2012, jul2012, oct2012)

```

`dplyr` does a pretty good job. The final object is only a few rows longer than each of the others, meaning that `dplyr` thinks the overlaps is almost perfect. Becuase I know this year manually I know this is true.
```{r}


## clean dups, find unique vector ---- 
# we want to determine the unqiue-ness across "list_name" and "value" only 
labs_2012 <- 
  long_2012 %>% 
  distinct(list_name, value, .keep_all = TRUE)

nrow(labs_2012)
```

For now, It would be easiest to just write this object into `iecodebook` template file, although in the long run I think there are better workflow options. But I can't figure out how to overwrite data in a sheet that already exists, so I'll just make a new one.

```{r}
write.xlsx(
  labs_2012,
  file = file.path(yr2012doc, "PHL_2012_append_template-IN - values.xlsx"),
  xy = c(1, 7), # vector of startCol, StartRow
  colNames = FALSE
  )
```


Trying again.
```{r}
# load workbook
PHL_2012_template <- loadWorkbook(file = file.path(yr2012doc, "PHL_2012_append_template-IN - Copy.xlsx"))

# write data
writeData(
  wb = PHL_2012_template, 
  sheet = "choices",
  x = labs_2012, 
  xy= c(1,1),
  colNames = TRUE, # the names need to be there for iecodebook to work.
  keepNA = FALSE
  )


saveWorkbook(PHL_2012_template, file = file.path(yr2012doc, "PHL_2012_append_template-IN - Copy.xlsx"), overwrite = TRUE)


```

The writing works, but the problem is that it's only writing one sheet at a time and not "writing" the rest, it seems. In other words, we are overwriting the whole file and including the one we "edit" by specifiying the object `labs_2012` -- the other sheets are also overwritten by the program and in these sheets we cannot, it seems, specify to keep NA values as empty cells, which means we have to live with overwritten, sloppy, output in the rest of the sheet if we are to go with this approach. 


## Method 2: retroharmonize

I found this package designed to harmonize things about complex surveys. Let's try it! Note that If I could actually get the final step in part 1 to work -- ie, the writing to the `iecodebook` codebook xlsx -- then I wouldn't be spending so much time in part 2. But for now we have **no** solution so I'll keep on keeping on until then.

### import 

First you have to import the raw `.dta` files. So here we go, `haven` in hand.

```{r, echo=FALSE}
jan2012dta <- read_dta(file = file.path(yr2012data, "LFSjan12.dta"))
apr2012dta <- read_dta(file = file.path(yr2012data, "LFSapr12.dta"))
jul2012dta <- read_dta(file = file.path(yr2012data, "LFSjul12.dta"))
oct2012dta <- read_dta(file = file.path(yr2012data, "LFS OCT2012.dta"))
```

Actually nevermind it looks like you have to create a metadata file first, also with `retroharmonize`

### Trying to import via creating metadata file, with errors

Note, folowing along first vignette. I don't actually import this successfully with metadata and I don't know why.

```{r}
i2d2   <- dir(yr2012data)
rounds <- file.path(yr2012data, i2d2) # store 2012 i2d2 directory 

i2d2_waves <- read_surveys(rounds, .f="read_dta", save_to_rds = FALSE) # example has "read_spss"
```


Giving more detailed description to each round,
```{r}
attr(i2d2_waves[[1]], "id") <- "PHL_2012_LFS_JAN"
attr(i2d2_waves[[2]], "id") <- "PHL_2012_LFS_APR"
attr(i2d2_waves[[3]], "id") <- "PHL_2012_LFS_JUL"
attr(i2d2_waves[[4]], "id") <- "PHL_2012_LFS_OCT"
```

Review Descriptive metadata. Looks like the package doesn't detect that the object is a `survey_list()` type, which prevents us from extracting metadata. However, we do see that the haven labeled attribute did make it's way through the function. I think something funky is happening with reading the stata files that is causing the function to not pick up on some of the metadata, ie, that makes it a survey_list.

```{r}
documented_i2d2_waves <- document_waves(i2d2_waves)

print(documented_i2d2_waves)
```

```{r}
print(attributes(i2d2_waves[[1]]$prov))
```


Let's try this `survey()`/`is.survey()` function they give us. Using the `.dta` file we already imported
```{r}
survey <- survey(
  df = jan2012, 
  id = "example"
)

is.survey(survey)
```

This is odd. Let's try to import all files manually via haven and then make into a list
```{r, echo=TRUE}
# take the dta objects we alredy imported earlier, giving them a string ID
jan <- survey(df = jan2012dta, id = "JanLFS")
apr <- survey(df = apr2012dta, id = "AprLFS")
jul <- survey(df = jul2012dta, id = "JulLFS")
oct <- survey(df = oct2012dta, id = "OctLFS")

is.survey(jan)
is.survey(apr)
is.survey(jul)
is.survey(oct)

# make 4 rounds into a list
i2d2_waves2 <- list(jan, apr, jul, oct)

```


But still, this second list object doens't read as a `survey_list()` object, even though it is a list of surveys...

```{r,}
document_waves(i2d2_waves2)
```


### maybe it has to be SPSS?

Ok so maybe since the package was specifically designed(?) for SPSS files the metadata stuff only works with SPSS. 

Let's export to SPSS with `haven`. Low key this takes like 10 minutes...

```{r}
write_sav(jan2012dta, file.path(yr2012data, "SPSS/LFSjan12.sav"))
write_sav(apr2012dta, file.path(yr2012data, "SPSS/LFSapr12.sav"))
write_sav(jul2012dta, file.path(yr2012data, "SPSS/LFSjul12.sav"))
write_sav(oct2012dta, file.path(yr2012data, "SPSS/LFSoct12.sav"))

```


And now import the SPSS files with the function like good vignette readers.

```{r}
# adjust the directory first
i2d2_spss <- dir(vSPSS)
rounds_spss <- file.path(vSPSS, i2d2_spss) # store 2012 i2d2 directory 

i2d2_waves3 <- read_surveys(rounds_spss, .f="read_spss", save_to_rds = FALSE) # example has "read_spss"
```

And is our SPSS-imported object a `survey_list()`? Apparently yes??
```{r}
documented_i2d2_waves <- document_waves(i2d2_waves3)
documented_i2d2_waves
```

## working with metadata 

Extract metadata and save in obeject
```{r}
i2d2_metadata <- lapply( X = i2d2_waves3, FUN = metadata_create)
i2d2_metadata <- do.call(rbind, i2d2_metadata)
head(i2d2_metadata)
```

Ok now the vingette wants us to select a subset of variables to work with so we can harmonize the whole set of rounds based on these variables. Sure, why not.
```{r}
# declare a vector of key variables we don't want
vars <- c("creg", "stratum", "psu", "prov", "hhid", "svymo", 
         "svyyr", "c04_lno", "c05_rel", "c06_sex", "c07_age", "c08_mstat", "a02_cursch",
        "c10_conwr", "j01_usocc", "c13_work", "c14_job", "c16_procc", 
        "c18_pkb", "c19_pclass", "c20_natem", "c21_pnwhrs",
        "c22_phours", "c23_pwmore", "c24_pladdw", "c25_pfwrk", "c26_pbasis", 
        "c27_pbasic", "c28_ojob", "j02_otocc",
        "j03_okb", "j04_oclass", "j05_ohours", "j06_obasis", 
        "j07_obasic", "a03_jobs", "a04_thours", "a05_rwm48h",
        "c37_avail", "c38_lookw", "c39_jobsm", "c40_weeks", 
        "c41_flwrk", "c42_wynot", "a06_ltlookw", "a07_willing",
        "c43_lbef", "c45_pocc", "a08_wpqtr", "a09_pqkb", "cempst1", "newempstat", "hhnum", "urb2k1970",
        "j12intvw", "j12c09_grade", "j12c11_gradtech", "j12c11course", "pwgt", "weight"
)

to_harmonize <- i2d2_metadata %>%
  filter(var_name_orig %in% vars ) %>%
  mutate( var_label = var_label_normalize(label_orig)) %>% # removes spaces, special characters and typos
  mutate( var_name  = val_label_normalize(var_label))
  
```


## Harmonizing/Merging 

Merge the surveys. Apparently this function harmonizes variable names, variable labels, and survey identifiers -- but what about value labels??
```{r}
merged_i2d2 <- merge_waves(waves = i2d2_waves3, var_harmonization = to_harmonize)
document_waves(merged_i2d2)
```


## pausing here.

this is where I'm pausing for now. Basically I've concluded that this package has a lot of potential. The biggest advantage for us so far is the `metadata` object which lists all varnames, labels and value labels for each round in a tibble. It seems that from here is where the package originates a lot of its operations. Downside is having stepping into SPSS from Stata. (Can it be done with Rds?)